<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Endpoint.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">r43ples</a> &gt; <a href="index.source.html" class="el_package">de.tud.plt.r43ples.webservice</a> &gt; <span class="el_source">Endpoint.java</span></div><h1>Endpoint.java</h1><pre class="source lang-java linenums">package de.tud.plt.r43ples.webservice;

import java.io.ByteArrayOutputStream;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.ws.rs.*;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Request;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Response.ResponseBuilder;
import javax.ws.rs.core.UriInfo;
import javax.ws.rs.core.Variant;

import de.tud.plt.r43ples.core.HeaderInformation;
import de.tud.plt.r43ples.core.R43plesCoreInterface;
import de.tud.plt.r43ples.core.R43plesCoreSingleton;
import de.tud.plt.r43ples.existentobjects.InitialCommit;
import de.tud.plt.r43ples.existentobjects.MergeCommit;
import de.tud.plt.r43ples.iohelper.JenaModelManagement;
import de.tud.plt.r43ples.management.*;
import org.apache.log4j.Logger;

import com.github.mustachejava.DefaultMustacheFactory;
import com.github.mustachejava.Mustache;
import com.github.mustachejava.MustacheFactory;
import com.hp.hpl.jena.rdf.model.Model;
import com.hp.hpl.jena.shared.NoWriterForLangException;

import de.tud.plt.r43ples.exception.InternalErrorException;
import de.tud.plt.r43ples.exception.QueryErrorException;
import de.tud.plt.r43ples.mergingUI.ui.MergingControl;



/**
 * Provides SPARQL endpoint via [host]:[port]/r43ples/.
 * Supplies version information, service description as well as SPARQL queries.
 * 
 * @author Stephan Hensel
 * @author Markus Graube
 * @author Xinyu Yang
 * 
 */
@Path(&quot;sparql&quot;)
<span class="fc" id="L53">public class Endpoint {</span>

	
	@Context
	private UriInfo uriInfo;
	@Context
	private Request request;
	
	

	
	/** default logger for this class */
<span class="fc" id="L65">	private final static Logger logger = Logger.getLogger(Endpoint.class);</span>


<span class="fc" id="L68">	static final MediaType TEXT_TURTLE_TYPE = new MediaType(&quot;text&quot;, &quot;turtle&quot;);</span>
<span class="fc" id="L69">	static final MediaType APPLICATION_RDF_XML_TYPE = new MediaType(&quot;application&quot;, &quot;rdf+xml&quot;);</span>
<span class="fc" id="L70">	static final MediaType APPLICATION_SPARQL_RESULTS_XML_TYPE = new MediaType(&quot;application&quot;, &quot;sparql-results+xml&quot;);</span>
	
	
	/**map for client and mergingControlMap
	 * for each client there is a mergingControlMap**/
<span class="fc" id="L75">	protected static HashMap&lt;String, HashMap&lt;String, MergingControl&gt;&gt; clientMap = new HashMap&lt;String, HashMap&lt;String, MergingControl&gt;&gt;();</span>
	
	


	/**
	 * HTTP POST interface for query and update (e.g. SELECT, INSERT, DELETE).
	 * 
	 * @param revision_information
	 *            (optional) recent revision information about used revision graphs. If exisitent, commits are only
	 *            performed if revision information is up to date.
	 * @param formatQuery
	 *            format specified in the HTTP parameters
	 * @param sparqlQuery
	 *            the SPARQL query
	 * @param query_rewriting
	 * 			  should query rewriting option be used
	 * @return HTTP response
	 * @throws InternalErrorException 
	 */
	@POST
	@Produces({ MediaType.TEXT_PLAIN, MediaType.TEXT_HTML, MediaType.APPLICATION_JSON, &quot;application/rdf+xml&quot;, &quot;text/turtle&quot;, &quot;application/sparql-results+xml&quot;})
	@Consumes(MediaType.APPLICATION_FORM_URLENCODED)
	public final Response sparqlPOST(
			@FormParam(&quot;format&quot;) final String formatQuery, 
			@FormParam(&quot;query&quot;) @DefaultValue(&quot;&quot;) final String sparqlQuery,
			@HeaderParam(&quot;r43ples-revisiongraph&quot;) @DefaultValue(&quot;&quot;) final String revision_information,
			@FormParam(&quot;query_rewriting&quot;) @DefaultValue(&quot;&quot;) final String query_rewriting) throws InternalErrorException {
		try {
<span class="nc" id="L104">			String format = getFormat(formatQuery);</span>
<span class="nc" id="L105">			logger.info(&quot;SPARQL POST query (format: &quot;+format+&quot;, query: &quot;+sparqlQuery +&quot;)&quot; + revision_information);</span>
<span class="nc" id="L106">			return sparql(format, sparqlQuery, revision_information, query_rewriting);</span>
<span class="nc" id="L107">		} catch (Exception e) {</span>
<span class="nc" id="L108">			return Response.serverError().status(Response.Status.NOT_ACCEPTABLE).build();</span>
		}
	}

	private String getFormat(final String formatQuery) throws Exception {
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">		if (formatQuery == null){</span>
<span class="nc" id="L114">			List&lt;Variant&gt; reqVariants = Variant.mediaTypes(MediaType.TEXT_PLAIN_TYPE, MediaType.TEXT_HTML_TYPE, </span>
					MediaType.APPLICATION_JSON_TYPE, TEXT_TURTLE_TYPE, APPLICATION_RDF_XML_TYPE, APPLICATION_SPARQL_RESULTS_XML_TYPE).build();
<span class="nc" id="L116">			Variant bestVariant = request.selectVariant(reqVariants);</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">	        if (bestVariant == null) {</span>
<span class="nc" id="L118">	        	throw new Exception(&quot;Requested datatype not available&quot;);</span>
	        }
<span class="nc" id="L120">        	MediaType reqMediaType = bestVariant.getMediaType();</span>
<span class="nc" id="L121">        	return reqMediaType.toString();</span>
		}
		else {
<span class="fc" id="L124">			return formatQuery;</span>
		}
	}
	
	/**
	 * HTTP POST interface for query and update (e.g. SELECT, INSERT, DELETE).
	 * Direct method (http://www.w3.org/TR/2013/REC-sparql11-protocol-20130321/#query-via-post-direct)
	 *
	 * @param revision_information
	 *            (optional) recent revision information about used revision graphs. If exisitent, commits are only
	 *            performed if revision information is up to date.
	 * @param sparqlQuery
	 *            the SPARQL query specified in the HTTP POST body
	 * @return HTTP response
	 * @throws InternalErrorException 
	 */
	@POST
	@Produces({ MediaType.TEXT_PLAIN, MediaType.TEXT_HTML, MediaType.APPLICATION_JSON, &quot;application/rdf+xml&quot;, &quot;text/turtle&quot;, &quot;application/sparql-results+xml&quot; })
	@Consumes(&quot;application/sparql-query&quot;)
	public final Response sparqlPOSTdirectly(
			@HeaderParam(&quot;r43ples-revisiongraph&quot;) @DefaultValue(&quot;&quot;) final String revision_information,
			final String sparqlQuery) throws InternalErrorException {
<span class="fc" id="L146">		List&lt;Variant&gt; reqVariants = Variant.mediaTypes(MediaType.TEXT_PLAIN_TYPE, MediaType.TEXT_HTML_TYPE, </span>
				MediaType.APPLICATION_JSON_TYPE, TEXT_TURTLE_TYPE, APPLICATION_RDF_XML_TYPE, APPLICATION_SPARQL_RESULTS_XML_TYPE).build();
<span class="fc" id="L148">		Variant bestVariant = request.selectVariant(reqVariants);</span>
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        if (bestVariant == null) {</span>
<span class="nc" id="L150">            return Response.serverError().status(Response.Status.NOT_ACCEPTABLE).build();</span>
        }
<span class="fc" id="L152">    	MediaType reqMediaType = bestVariant.getMediaType();</span>
<span class="fc" id="L153">    	String format = reqMediaType.toString();</span>
<span class="fc" id="L154">		logger.info(&quot;SPARQL POST query directly (format: &quot;+format+&quot;, query: &quot;+sparqlQuery +&quot;)&quot;);</span>
<span class="fc" id="L155">		return sparql(reqMediaType.toString(), sparqlQuery, revision_information, false);</span>
	}
	
	/**
	 * HTTP GET interface for query and update (e.g. SELECT, INSERT, DELETE).
	 * Provides HTML form if no query is specified and HTML is requested
	 * Provides Service Description if no query is specified and RDF
	 * representation is requested
	 *
	 * @param revision_information
	 *            (optional) recent revision information about used revision graphs. If exisitent, commits are only
	 *            performed if revision information is up to date.
	 * @param formatQuery
	 *            format specified in the HTTP parameters
	 * @param sparqlQuery
	 *            the SPARQL query
	 * @param query_rewriting
	 * 			  should query rewriting option be used
	 * @return HTTP response
	 * @throws InternalErrorException 
	 */
	@GET
	@Produces({ MediaType.TEXT_PLAIN, MediaType.TEXT_HTML, MediaType.APPLICATION_JSON, &quot;application/rdf+xml&quot;, &quot;text/turtle&quot;, &quot;application/sparql-results+xml&quot; })
	public final Response sparqlGET(
			@QueryParam(&quot;format&quot;) final String formatQuery, 
			@QueryParam(&quot;query&quot;) @DefaultValue(&quot;&quot;) final String sparqlQuery,
			@HeaderParam(&quot;r43ples-revisiongraph&quot;) @DefaultValue(&quot;&quot;) final String revision_information,
			@QueryParam(&quot;query_rewriting&quot;) @DefaultValue(&quot;&quot;) final String query_rewriting) throws InternalErrorException {
		String format;
		try {
<span class="fc" id="L185">			format = getFormat(formatQuery);</span>
<span class="nc" id="L186">		} catch (Exception e) {</span>
<span class="nc" id="L187">			return Response.serverError().status(Response.Status.NOT_ACCEPTABLE).build();</span>
<span class="fc" id="L188">		}		</span>
		
		String sparqlQueryDecoded;
		try {
<span class="fc" id="L192">			sparqlQueryDecoded = URLDecoder.decode(sparqlQuery, &quot;UTF-8&quot;);</span>
<span class="nc" id="L193">		} catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L194">			e.printStackTrace();</span>
<span class="nc" id="L195">			sparqlQueryDecoded = sparqlQuery;</span>
<span class="fc" id="L196">		}</span>
<span class="fc" id="L197">		logger.info(&quot;SPARQL GET query (format: &quot;+format+&quot;, query: &quot;+sparqlQueryDecoded +&quot;)&quot;);</span>
<span class="fc" id="L198">		return sparql(format, sparqlQueryDecoded, revision_information, query_rewriting);</span>
	}
	
	
	
	/**
	 * Interface for query and update (e.g. SELECT, INSERT, DELETE).
	 * Provides HTML form if no query is specified and HTML is requested
	 * Provides Service Description if no query is specified and RDF
	 * representation is requested
	 * 
	 * @param format
	 *            mime type for response format
	 * @param sparqlQuery
	 *            decoded SPARQL query
	 * @param revision_information
	 *            (optional) recent revision information about used revision graphs. If exisitent, commits are only
	 *            performed if revision information is up to date.
	 * @param query_rewriting
	 * 			  should query rewriting option be used
	 * @return the response
	 * @throws InternalErrorException 
	 */
	private final Response sparql(final String format, final String sparqlQuery, final String revision_information, final boolean query_rewriting) throws InternalErrorException {
<span class="fc bfc" id="L222" title="All 2 branches covered.">		if (&quot;&quot;.equals(sparqlQuery)) {</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">			if (format.contains(MediaType.TEXT_HTML)) {</span>
<span class="fc" id="L224">				return getHTMLResponse();</span>
			} else {
<span class="fc" id="L226">				return getServiceDescriptionResponse(format);</span>
			}
		} else {
<span class="fc" id="L229">			return getSparqlResponse(format, sparqlQuery, revision_information, query_rewriting);</span>
		}
	}

	/**
	 * Interface for query and update (e.g. SELECT, INSERT, DELETE).
	 * Provides HTML form if no query is specified and HTML is requested
	 * Provides Service Description if no query is specified and RDF
	 * representation is requested
	 *
	 * @param format
	 *            mime type for response format
	 * @param sparqlQuery
	 *            decoded SPARQL query
	 * @param query_rewriting
	 * 			  should query rewriting option be used
	 * @return the response
	 * @throws InternalErrorException
	 */
	public final Response sparql(final String format, final String sparqlQuery, final boolean query_rewriting) throws InternalErrorException {
<span class="fc" id="L249">		return sparql(format, sparqlQuery, null, query_rewriting);</span>
	}
	
	/**
	 * 
	 * @param format
	 *            mime type for response format
	 * @param sparqlQuery
	 *            decoded SPARQL query
	 * @param revision_information
	 *            (optional) recent revision information about used revision graphs. If exisitent, commits are only
	 *            performed if revision information is up to date.
	 * @param query_rewriting
	 * 			  string determining if query rewriting option be used
	 * @return
	 * @throws InternalErrorException
	 */
	private Response sparql(final String format, final String sparqlQuery, final String revision_information, final String query_rewriting) throws InternalErrorException {
<span class="fc" id="L267">		String option = query_rewriting.toLowerCase();</span>
<span class="pc bpc" id="L268" title="2 of 6 branches missed.">		if (option.equals(&quot;on&quot;) || option.equals(&quot;true&quot;) || option.equals(&quot;new&quot;))</span>
<span class="fc" id="L269">			return sparql(format, sparqlQuery, revision_information, true);</span>
		else
<span class="fc" id="L271">			return sparql(format, sparqlQuery, revision_information, false);</span>
	}
	
	/**
	 * Interface for query and update (e.g. SELECT, INSERT, DELETE).
	 * Provides HTML form if no query is specified and HTML is requested
	 * Provides Service Description if no query is specified and RDF
	 * representation is requested
	 * 
	 * @param format
	 *            mime type for response format
	 * @param sparqlQuery
	 *            decoded SPARQL query
	 * @return the response
	 * @throws InternalErrorException 
	 */
	public final Response sparql(final String format, final String sparqlQuery) throws InternalErrorException {
<span class="fc" id="L288">		return sparql(format, sparqlQuery, null, false);</span>
	}
	
	
	public final Response sparql(final String sparqlQuery) throws InternalErrorException {
<span class="fc" id="L293">		return sparql(&quot;application/xml&quot;, sparqlQuery, null, false);</span>
	}
	
	
	

	/**
	 * Get HTML response for standard sparql request form.
	 * Using mustache templates. 
	 * 
	 * @return HTML response for SPARQL form
	 */
	private Response getHTMLResponse() {
<span class="fc" id="L306">		logger.info(&quot;SPARQL form requested&quot;);</span>
<span class="fc" id="L307">		MustacheFactory mf = new DefaultMustacheFactory();</span>
<span class="fc" id="L308">	    Mustache mustache = mf.compile(&quot;templates/endpoint.mustache&quot;);</span>
<span class="fc" id="L309">	    StringWriter sw = new StringWriter();</span>
<span class="fc" id="L310">		Map&lt;String, Object&gt; htmlMap = new HashMap&lt;String, Object&gt;();</span>
<span class="fc" id="L311">	    htmlMap.put(&quot;graphList&quot;, RevisionManagementOriginal.getRevisedGraphsList());</span>
<span class="fc" id="L312">	    htmlMap.put(&quot;endpoint_active&quot;, true);</span>
<span class="fc" id="L313">	    mustache.execute(sw, htmlMap);		</span>
<span class="fc" id="L314">		String content = sw.toString();</span>
<span class="fc" id="L315">		return Response.ok().entity(content).type(MediaType.TEXT_HTML).build();</span>
	}


	
	/**
	 * Generates HTML representation of SPARQL query result 
	 * @param query SPARQL query which was passed to R43ples
	 * @param result result from the attached triplestore
	 */
	private String getHTMLResult(final String result, String query) {
<span class="fc" id="L326">		return getHTMLResult(result, query, null);</span>
	}
	
	/**
	 * Generates HTML representation of SPARQL query result including the rewritten query 
	 * @param query SPARQL query which was passed to R43ples
	 * @param query_rewritten rewritten SPARQL query passed to triplestore
	 * @param result result from the attached triplestore
	 */
	private String getHTMLResult(final String result, String query, String query_rewritten) {
<span class="fc" id="L336">		MustacheFactory mf = new DefaultMustacheFactory();</span>
<span class="fc" id="L337">		Mustache mustache = mf.compile(&quot;templates/result.mustache&quot;);</span>
<span class="fc" id="L338">		StringWriter sw = new StringWriter();</span>
<span class="fc" id="L339">		Map&lt;String, Object&gt; htmlMap = new HashMap&lt;String, Object&gt;();</span>
<span class="fc" id="L340">		htmlMap.put(&quot;endpoint_active&quot;, true);</span>
<span class="fc" id="L341">		htmlMap.put(&quot;result&quot;, result);</span>
<span class="fc" id="L342">		htmlMap.put(&quot;query&quot;, query);</span>
<span class="fc" id="L343">		htmlMap.put(&quot;query_rewritten&quot;, query_rewritten);</span>
<span class="fc" id="L344">		mustache.execute(sw, htmlMap);		</span>
<span class="fc" id="L345">		return sw.toString();</span>
	}

	
	/**
	 * @param format
	 * 			requested mime type 
	 * @param sparqlQuery
	 * 			string containing the SPARQL query
	 * @param query_rewriting
	 * 			  should query rewriting option be used
	 * @return HTTP response of evaluating the sparql query 
	 * @throws InternalErrorException
	 */
	private Response getSparqlResponse(String format, String sparqlQuery, final String revision_information, final boolean query_rewriting) throws InternalErrorException {
<span class="fc" id="L360">		logger.info(String.format(&quot;SPARQL request (format=%s, query_rewriting=%s, header=%s) -&gt; %n %s&quot;, format, query_rewriting,revision_information, sparqlQuery));</span>

<span class="fc" id="L362">		R43plesCoreInterface r43plesCore = R43plesCoreSingleton.getInstance();</span>

<span class="fc" id="L364">		R43plesRequest request = new R43plesRequest(sparqlQuery, format, revision_information);</span>

		String result;
<span class="fc bfc" id="L367" title="All 2 branches covered.">		if (request.isSelectAskConstructQuery()) {</span>
<span class="fc" id="L368">			result = r43plesCore.getSparqlSelectConstructAskResponse(request, query_rewriting);</span>
		}
<span class="fc bfc" id="L370" title="All 2 branches covered.">		else if (request.isUpdateQuery()) {</span>
<span class="fc" id="L371">			r43plesCore.createUpdateCommit(request);</span>
<span class="fc" id="L372">			result = &quot;Query executed&quot;;</span>
		}
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">		else if (request.isCreateGraphQuery()) {</span>
<span class="nc" id="L375">			InitialCommit initialCommit = r43plesCore.createInitialCommit(request);</span>
<span class="nc" id="L376">			result = &quot;Graph &lt;&quot; + initialCommit.getGeneratedRevision().getRevisionGraph().getGraphName() + &quot;&gt; successfully created&quot;;</span>
<span class="nc" id="L377">		}</span>
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">		else if (request.isDropGraphQuery()) {</span>
<span class="nc" id="L379">			r43plesCore.sparqlDropGraph(sparqlQuery);</span>
<span class="nc" id="L380">			result = &quot;Graph successfully dropped&quot;;</span>
		}
<span class="fc bfc" id="L382" title="All 2 branches covered.">		else if (request.isBranchOrTagQuery()) {</span>
<span class="fc" id="L383">			r43plesCore.createReferenceCommit(request);</span>
<span class="fc" id="L384">			result = &quot;Tagging or branching successful&quot;;</span>
		}
<span class="fc bfc" id="L386" title="All 2 branches covered.">		else if (request.isMergeQuery()) {</span>
<span class="fc" id="L387">            logger.info(&quot;Merge query detected&quot;);</span>
<span class="fc" id="L388">            return getMergeResponse(r43plesCore.createMergeCommit(request), request);</span>
		}
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">		else if (request.isPickQuery()) {</span>
<span class="nc" id="L391">			logger.info(&quot;Pick query detected&quot;);</span>
<span class="nc" id="L392">			r43plesCore.createPickCommit(request);</span>
<span class="nc" id="L393">			result = &quot;Revision(s) successfully picked&quot;;</span>
		}
		else
<span class="fc" id="L396">			throw new QueryErrorException(&quot;No R43ples query detected&quot;);</span>

<span class="fc" id="L398">		ResponseBuilder responseBuilder = Response.ok();</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">		if (format.equals(&quot;text/html&quot;)){</span>
<span class="pc bpc" id="L400" title="1 of 2 branches missed.">			if (query_rewriting) {</span>
<span class="nc" id="L401">				responseBuilder.entity(getHTMLResult(result, sparqlQuery, SparqlRewriter.rewriteQuery(sparqlQuery)));</span>
			}
			else {
<span class="fc" id="L404">				responseBuilder.entity(getHTMLResult(result, sparqlQuery));</span>
			}
		} else {
<span class="fc" id="L407">			responseBuilder.entity(result);</span>
		}
<span class="fc" id="L409">		responseBuilder.type(format);</span>
<span class="fc" id="L410">		HeaderInformation hi = new HeaderInformation();</span>
<span class="fc" id="L411">		responseBuilder.header(&quot;r43ples-revisiongraph&quot;, hi.getResponseHeaderFromQuery(sparqlQuery));</span>
<span class="fc" id="L412">		return responseBuilder.build();</span>
	}


	
	/**
	 * Provides the SPARQL Endpoint description of the original sparql endpoint
	 * with the additional R43ples feature (sd:feature) and replaced URIs.
	 * 
	 * @param format
	 *            serialisation format of the service description
	 * @return Extended Service Description
	 */
	private Response getServiceDescriptionResponse(final String format) {
<span class="fc" id="L426">		logger.info(&quot;Service Description requested&quot;);</span>
<span class="fc" id="L427">		String triples =String.format(&quot;@prefix rdf:	&lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; . %n&quot;</span>
				+ &quot;@prefix ns3:	&lt;http://www.w3.org/ns/formats/&gt; .%n&quot;
				+ &quot;@prefix sd:	&lt;http://www.w3.org/ns/sparql-service-description#&gt; .%n&quot;
				+ &quot;&lt;%1$s&gt;	rdf:type	sd:Service ;%n&quot;
				+ &quot;	sd:endpoint	&lt;%1$s&gt; ;%n&quot;
				+ &quot;	sd:feature	sd:r43ples ;&quot;
				+ &quot;	sd:resultFormat	ns3:SPARQL_Results_JSON ,%n&quot;
				+ &quot;		ns3:SPARQL_Results_XML ,%n&quot;
				+ &quot;		ns3:Turtle ,%n&quot;
				+ &quot;		ns3:N-Triples ,%n&quot;
				+ &quot;		ns3:N3 ,%n&quot;
				+ &quot;		ns3:RDF_XML ,%n&quot;
				+ &quot;		ns3:SPARQL_Results_CSV ,%n&quot;
				+ &quot;		ns3:RDFa ;%n&quot;
				+ &quot;	sd:supportedLanguage	sd:SPARQL10Query, sd:SPARQL11Query, sd:SPARQL11Query, sd:SPARQL11Update, sd:R43plesQuery  ;%n&quot;
				+ &quot;	sd:url	&lt;%1$s&gt; .%n&quot;, uriInfo.getAbsolutePath()) ;
<span class="fc" id="L443">		Model model = JenaModelManagement.readStringToJenaModel(triples, &quot;TURTLE&quot;);</span>
<span class="fc" id="L444">		ByteArrayOutputStream baos = new ByteArrayOutputStream();</span>
		
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">		if (format.toLowerCase().contains(&quot;xml&quot;) )</span>
<span class="nc" id="L447">			model.write(baos, &quot;RDF/XML&quot;);</span>
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">		else if (format.toLowerCase().contains(&quot;turtle&quot;) )</span>
<span class="fc" id="L449">			model.write(baos, &quot;Turtle&quot;);</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">		else if (format.toLowerCase().contains(&quot;json&quot;) )</span>
<span class="nc" id="L451">			model.write(baos, &quot;RDF/JSON&quot;);</span>
		else {
			try {
<span class="nc" id="L454">				model.write(baos, format);</span>
			}
<span class="nc" id="L456">			catch (NoWriterForLangException e) {</span>
<span class="nc" id="L457">				model.write(baos, &quot;Turtle&quot;);</span>
<span class="nc" id="L458">			}</span>
		}
<span class="fc" id="L460">		return Response.ok().entity(baos.toString()).build();</span>
	}


	/** 
	 * Creates the merge response.
	 *
	 * @param commit merge commit object containing all information about the merge
     * @param request the original R43ples request.
	 *
	 * @return the http response
	 * @throws InternalErrorException 
	 */
	private Response getMergeResponse(MergeCommit commit, R43plesRequest request) throws InternalErrorException {
<span class="fc" id="L474">		ResponseBuilder responseBuilder = Response.created(URI.create(&quot;&quot;));</span>

<span class="fc bfc" id="L476" title="All 2 branches covered.">		if (commit.isHasConflict()) {</span>
<span class="fc" id="L477">			responseBuilder = Response.status(Response.Status.CONFLICT);</span>
<span class="fc" id="L478">			responseBuilder.entity(commit.getConflictModel());</span>
		}
		String graphNameHeader;
		try {
<span class="fc" id="L482">			graphNameHeader = URLEncoder.encode(commit.getRevisionGraph().getGraphName(), &quot;UTF-8&quot;);</span>
<span class="nc" id="L483">		} catch (UnsupportedEncodingException e) {</span>
<span class="nc" id="L484">			e.printStackTrace();</span>
<span class="nc" id="L485">			graphNameHeader = commit.getRevisionGraph().getGraphName();</span>
<span class="fc" id="L486">		}</span>
		
		// Return the revision identifiers which were used (convert tag or branch identifier to revision identifier)
<span class="fc" id="L489">		responseBuilder.header(graphNameHeader + &quot;-revision-number-of-branch-From&quot;, commit.getUsedSourceRevision().getRevisionIdentifier());</span>
<span class="fc" id="L490">		responseBuilder.header(graphNameHeader + &quot;-revision-number-of-branch-Into&quot;, commit.getUsedTargetRevision().getRevisionIdentifier());</span>

<span class="fc" id="L492">		HeaderInformation hi = new HeaderInformation();</span>
<span class="fc" id="L493">		responseBuilder.header(&quot;r43ples-revisiongraph&quot;, hi.getResponseHeaderFromQuery(request.query_sparql));</span>
		
<span class="fc" id="L495">		return responseBuilder.build();	</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.9.201702052155</span></div></body></html>